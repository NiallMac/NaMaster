\documentclass[a4paper,10pt]{article}
\usepackage{graphicx} % Include figure files
\usepackage{fullpage}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{amssymb,amsmath} 
%\usepackage{color}
%\usepackage[utf8x]{inputenc}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{listings}
\lstset{
language=C,
basicstyle=\footnotesize,
numbers=left,
numberstyle=\footnotesize,
stepnumber=1,
numbersep=5pt,
backgroundcolor=\color{white},
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=false,
tabsize=2,
captionpos=b,
breaklines=true,
breakatwhitespace=false,
escapeinside={\%*}{*)}
}

\newcommand{\vari}[2]{\textcolor{OliveGreen}{#1}{#2}}
\newcommand{\macr}[1]{{\tt \textcolor{BrickRed}{#1}}}
\newcommand{\functi}[3]{{\tt\textcolor{OliveGreen}{#1}
    \textcolor{blue}{#2}(#3)}}

\newenvironment{funcdef}[2][void main(void)]
{\vspace{12pt}\par\noindent{\large{\bf #1}}\vspace{5pt}
 \par\noindent\leftskip=20pt{{#2}}\vspace{5pt}
 \par\noindent\leftskip=5pt\rightskip=5pt}
{\par\leftskip=0pt\rightskip=0pt\vspace{12pt}}


%opening
\title{NaMaster: API documentation}
%\author{Dr No}

\begin{document}

\maketitle

\section{Introduction}

NaMaster is a C library, Python module and standalone program to compute full-sky angular cross-power spectra of masked, spin-0 and spin-2 fields with an arbitrary number of known contaminants using a pseudo-$C_\ell$ (aka MASTER) approach.

\subsection{Dependencies}
The following packages need to be installed before NaMaster.
\begin{itemize}
  \item {\bf GSL}: the GNU Scientific Library. This should be available in your usual software repositories (e.g. synaptic for linux), but you can also download and install it from \url{https://www.gnu.org/software/gsl/} (the installation follows the usual {\tt ./configure}, {\tt make}, {\tt make install} procedure.
  \item {\bf HEALPix}: the C HEALPix subroutines are also needed. HEALPix can be downloaded from \url{http://healpix.jpl.nasa.gov/}, and the C library can be compiled following the instructions after typing {\tt ./configure} and then {\tt make c-all}. The header and library files will then be placed in two local folders called {\tt include} and {\tt lib}. The user should then feel free to move these files to a different location.
  \item {\bf CFITSIO}: a FITS file subroutine library. This is used to read/write HEALPix maps in FITS format. {\tt cfitsio} can be downloaded from \url{http://heasarc.gsfc.nasa.gov/fitsio/fitsio.html}.
  \item {\bf Libsharp}: a fast C library for spherical harmonic transforms. Libsharp can be downloaded from its github repository: \url{https://github.com/dagss/libsharp}. After cloning it, you should run {\tt autoreconf -i} to generate the configuration file. Then run {\tt ./configure} and {\tt make}, which will compile the library and place all compilation products in the folder {\tt ./auto}. The corresponding header and library files should then be manually moved to the desired installation directories.
\end{itemize}


\subsection{Compilation and usage}
\subsubsection*{Installing the C library and binaries}
NaMaster uses {\tt autotools} for installation, which means that you should be able to install it by simply typing
\begin{verbatim}
   ~$ ./configure
   ~$ make
   ~$ make install
\end{verbatim}
If you don't have default admin privileges you may have to precede the last command by {\tt sudo}. If you don't have admin privileges at all (i.e. you can't modify the contents of standard directories such as {\tt /usr/lib}), you can still install NaMaster by substituting the first command by {\tt ./configure --prefix=/path/to/dir}, where {\tt /path/to/dir} should be the full path of the directory where you want to install this package. This will create three sub-directories: {\tt /path/to/dir/include}, {\tt /path/to/dir/lib}, {\tt /path/to/dir/bin}, where the header, library and binary files will be placed respectively.

Note that, if you don't have admin privileges, probably some of the dependencies listed in the previous sections will also be installed in non-standard paths. If that is the case, you should make sure the environment variables {\tt CPPFLAGS} and {\tt LDFLAGS} contain the corresponding {\tt -I/path/to/dir2/include} and {\tt -L/path/to/dir2/lib} tags that point to the directories where these dependencies are installed (see \href{https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html}{this link} for more details on {\tt make} implicit variables).

\subsection*{Installing the python wrapper}
NaMaster comes equipped with a python wrapper. This is installed by running
\begin{verbatim}
   ~$ python setup.py install
\end{verbatim}
Without admin privileges you can still make this work by running
\begin{verbatim}
   ~$ python setup.py install --user
\end{verbatim}
The python wrapper needs to link with NaMaster's library. If the latter was installed in a non-standard path (e.g. {\tt /path/to/install}), you'll need to pass the corresponding directory to {\tt setup.py}. You can do so by running
\begin{verbatim}
   ~$ python setup.py build_ext --library-dirs=/path/to/install/lib/
       --rpath=/path/to/install/lib/
\end{verbatim}
before the install commands above.

Note that currently the python wrapper requires the user to have the SWIG package installed (this will be changed in the future). SWIG can be found in the standard software repositories and at \url{http://www.swig.org/}.

\subsection*{Linking with the C library}
If you want to use NaMaster on your own C code you'll need to be able to link with {\tt libnmt} (the NaMaster C library). There are two main things to do:
\begin{enumerate}
 \item Make sure to include the NaMaster header in any C file that makes use of any of the NaMaster subroutines:
       \begin{verbatim}
         #include <namaster.h>
       \end{verbatim}
 \item When compiling your code, make sure you link to {\tt libnmt} and all dependencies. In the simplest case, assuming you have written a C script called {\tt min\_code.c}, the following should work:
       \begin{verbatim}
         gcc -fopenm -I/path/to/nmt/include min_code.c -o min_code
             -L/path/to/nmt/lib -lnmt -lsharp -lfftpack -lc_utils
             -lchealpix -lcfitsio -lgsl -lgslcblas -lm
       \end{verbatim}
       where {\tt /path/to/nmt/include} and {\tt /path/to/nmt/lib} are the directories where {\tt namaster.h} and {\tt libnmt.so} are installed.
\end{enumerate}
Section \ref{sec:sample} below contains a fully working C script that calls the NaMaster library.

\newpage
\section{C documentation}
Important note: all HEALPix maps passed to NaMaster routines should be in RING order.

\subsection{Fields}
The definition of the fields to be correlated (including their masks and possible contaminants) is handled through a C structure called {\tt nmt\_field}. The following routines exist to manage this structure:

\begin{funcdef}[nmt\_field\_alloc]
 {\functi{nmt\_field *}{nmt\_field\_alloc}
 {\vari{long}{ nside},\vari{double *}{mask},\vari{int}{ pol},\vari{double **}{maps},\\\vari{int}{ ntemp},\vari{flouble ***}{temp}}}
 This is the constructor for {\tt nmt\_field}. The input variables are:
 \begin{itemize}[noitemsep]
   \item {\tt nside}: the HEALPix resolution of all maps involved
   \item {\tt mask}: sky mask (as a single scalar HEALPix map).
   \item {\tt pol}: set to 0 if this is a spin-0 field. Set to 1 if it's a spin-2 field.
   \item {\tt maps}: set of maps corresponding to observed field. This would correspond to one map for a scalar field or two maps for spin-2 quantities (e.g. Q and U for polarization maps or $\gamma_1$, $\gamma_2$ for cosmic shear). The first dimension of this double array would correspond to the number of maps, while the second dimension runs through the different pixels of each map.
   \item {\tt ntemp}: number of contaminant templates for this field.
   \item {\tt temp}: contaminant templates as HEALPix maps. The first dimension should run through the different templates, the second dimension corresponds to the number of maps per template (e.g. 1 for spin-0 and 2 for spin-2) and the third dimension corresponds to the number of pixels.
 \end{itemize}
 \end{funcdef}

\begin{funcdef}[nmt\_field\_read]
 {\functi{nmt\_field *}{nmt\_field\_read}
 {\vari{char *}{fname\_mask},\vari{char *}{fname\_maps},\vari{char *}{fname\_temp},\vari{int }{pol}}}
 As {\tt nmt\_field\_alloc}, this returns a pointer to a {\tt nmt\_field} structure based on:
 \begin{itemize}[noitemsep]
   \item {\tt pol}: set to 0 if this is a spin-0 field. Set to 1 if it's a spin-2 field.
   \item {\tt fname\_mask}: file name pointing to a FITS file containing the sky mask (as a single scalar HEALPix map).
   \item {\tt fname\_maps}: file name pointing to a FITS file containing the maps of the observed field. This file should contain a single map for {\tt pol}=0 and two maps for {\tt pol}=1.
   \item {\tt fname\_temp}: file name pointing to a FITS file containing the contaminant templates as HEALPix maps. Each template should contain $N$ maps with $N=1$ for {\tt pol}=0 and $N=2$ for {\tt pol}=1.
 \end{itemize}
\end{funcdef}

\begin{funcdef}[nmt\_field\_free]
 {\functi{void}{nmt\_field\_free}{\vari{nmt\_field *}{fl}}}
 This frees up all memory associated to a previously-allocated {\tt nmt\_field}.
\end{funcdef}


\subsection{Binning scheme}
The definition of bandpowers is managed through C structures called {\tt nmt\_binning\_scheme}. The following routines allow you to interact with this structure:

\begin{funcdef}[nmt\_bins\_constant]
 {\functi{nmt\_binning\_scheme *}{nmt\_bins\_constant}{\vari{int }{nlb},\vari{int }{lmax}}}
 Creates an {\tt nmt\_binning\_scheme} structure (and returns a pointer to it) where the bandpowers are constant intervals of {\tt nlb} multipoles with equal weights between $\ell=2$ and $\ell={\tt lmax}$.
\end{funcdef}

\begin{funcdef}[nmt\_bins\_create]
{\functi{nmt\_binning\_scheme *}{nmt\_bins\_create}{\vari{int }{nell},\vari{int *}{bpws},\vari{int *}{ells},\\\vari{double *}{weights},\vari{int }{lmax}}}
 Creates an {\tt nmt\_binning\_scheme} structure (and returns a pointer to it) with bandpowers defined by the following parameters:
 \begin{itemize}[noitemsep]
  \item {\tt ells}: array of multipole indices
  \item {\tt bpws}: array containing the band power each $\ell$ in {\tt ells} corresponds to.
  \item {\tt weights}: array containing the weight for each $\ell$ in {\tt ells}. These need not be normalized, but they will be normalized such that the sum of weights within each bandpower equals 1.
  \item {\tt nell}: number of elements in the three previous arrays.
  \item {\tt lmax}: all multipoles $\ell>{\tt lmax}$ will be ignored.
 \end{itemize}
\end{funcdef}

\begin{funcdef}[nmt\_bins\_read]
{\functi{nmt\_binning\_scheme *}{nmt\_bins\_read}{\vari{char *}{fname},\vari{int }{lmax}}}
 Creates an {\tt nmt\_binning\_scheme} structure (and returns a pointer to it) with bandpowers defined by the contents of an ASCII file with name {\tt fname}. This file should contain three columns corresponding to the arrays {\tt bpws}, {\tt ells} and {\tt weights} passed to {\tt nmt\_bins\_create}. All multipoles $\ell>{\tt lmax}$ will be ignored.
\end{funcdef}

\begin{funcdef}[nmt\_bins\_free]
{\functi{void}{nmt\_bins\_free}{\vari{nmt\_binning\_scheme *}{bin}}}
 Frees all memory associated with an allocated {\tt nmt\_binning\_scheme} structure.
\end{funcdef}

\begin{funcdef}[nmt\_bin\_cls]
{\functi{void}{nmt\_bin\_cls}{\vari{nmt\_binning\_scheme *}{bin},\vari{double **}{cls\_in},\vari{double **}{cls\_out},\vari{int }{ncls}}}
 Performs a binning operation:
 \begin{equation}
   B_k=\sum_{\ell\in\vec{\ell}_k}w_\ell C_\ell.
 \end{equation}
 Here, $C_\ell\rightarrow{\tt cls\_in}$ is a set of {\tt ncls} angular power spectra, $B_k\rightarrow{\tt cls\_out}$ is a set of bandpowers and $w_\ell$ and $\vec{\ell}_k$ are the weights and multipole ranges defining the binning scheme {\tt bin}. Both {\tt cls\_in} and {\tt cls\_out} should have been previously allocated. The first dimension of both {\tt cls\_in} and {\tt cls\_out} should run from 0 to ${\tt ncls}-1$. Their second dimension should correspond to the number of multipoles and bandpowers used to create {\tt bin} respectively (for instance, the latter can be accessed as {\tt bin->n\_bands}).
\end{funcdef}

\begin{funcdef}[nmt\_unbin\_cls]
{\functi{void}{nmt\_unbin\_cls}{\vari{nmt\_binning\_scheme *}{bin},\vari{double **}{cls\_in},\vari{double **}{cls\_out},\vari{int }{ncls}}}
 Performs a un-binning operation:
 \begin{equation}
   C_\ell=\sum_k\,B_k\Theta(\ell\in\vec{\ell}_k)
 \end{equation}
 Here, $B_k\rightarrow{\tt cls\_in}$ is a set of {\tt ncls} bandpowers, $C_\ell\rightarrow{\tt cls\_out}$ is a set of angular power spectra and $w_\ell$ and $\vec{\ell}_k$ are the weights and multipole ranges defining the binning scheme {\tt bin}. The function $\Theta(\ell\in\ell_k)$ is $1$ for all multipoles contained in the $k$-th bandpower and zero otherwise. Both {\tt cls\_in} and {\tt cls\_out} should have been previously allocated. The first dimension of both {\tt cls\_in} and {\tt cls\_out} should run from 0 to ${\tt ncls}-1$. Their second dimension should correspond to the number of bandpowers and multipoles used to create {\tt bin} respectively (for instance, the former can be accessed as {\tt bin->n\_bands}).
\end{funcdef}

\begin{funcdef}[nmt\_ell\_eff]
 {\functi{void}{nmt\_ell\_eff}{\vari{nmt\_binning\_scheme *}{bin},\vari{double *}{larr}}}
 This function returns, in the output array {\tt larr}, the effective multipole corresponding to each bandpower defined by {\tt bin}. This is computed as:
 \begin{equation}
   \ell^{\rm eff}_k=\sum_{\ell\in\vec{\ell}_k}\ell\,w_\ell,
 \end{equation}
 where $w_\ell$ are the bandpower weights. {\tt larr} should have been previously allocated to the number of bandpowers defined by {\tt bin}.
\end{funcdef}

\subsection{Pseudo-$C_\ell$}
The implementation of the pseudo-$C_\ell$ estimator can be split into the following steps:
\begin{enumerate}
  \item Clean up your best guess of the known contaminants in your data maps. This step can be skipped if you think your maps are clean of contaminants. This step is automatically carried out when initializing an {\tt nmt\_field} structure with template contaminants.
  \item Compute the cross-pseudo-$C_\ell$ of the cleaned maps $\tilde{C}^{\rm clean}_\ell$.
  \item Compute the bias on the pseudo-$C_\ell$ caused by the statistical residual contaminants $\tilde{C}^{\rm cont}_\ell$.
  \item Compute the mode-coupling matrix associated with the field masks ${\sf M}_{\ell\ell'}$.
  \item Compute the de-coupled and de-biased bandpowers:
        \begin{equation}\label{eq:master_full}
          B_k=\sum_{k'}(\mathcal{M})^{-1}_{kk'}\sum_{\ell\in\vec{\ell}_{k'}}w_{\ell'}\left[\tilde{C}^{\rm clean}_{\ell'}-\tilde{C}^{\rm bias}_{\ell'}-\tilde{C}^{\rm noise}_{\ell'}\right],
        \end{equation}
        where $\mathcal{M}$ is the binned coupling matrix:
        \begin{equation}
          \mathcal{M}_{kk'}\equiv\sum_{\ell\in\vec{\ell}_k}\sum_{\ell'\in\vec{\ell}_{k'}}w_\ell{\sf M}_{\ell\ell'}.
        \end{equation}
        When auto-correlating a field with noise, it is in general also desirable to remove the noise bias on the power spectrum. This has been included in Eq. \ref{eq:master_full} above as $\tilde{C}^{\rm noise}_\ell$. This should be the pseudo-$C_\ell$ of the noise component (i.e. the angular power spectrum of masked noise realizations), which can be computed from Monte-Carlo simulations (or analytically for sufficiently simple noise models).
\end{enumerate}
In NaMaster, these computations are carried out through a C structure called {\tt nmt\_workspace}. The relevant functions are described below.


{\tt nmt\_apodize\_mask}

\section{Macros}

The following preprocessor macros, defined in the header file, are used
by CosmoMad and may be used by any code linked to it:
\begin{itemize}
 \item \macr{CSM\_FOURPITHIRD} : $\frac{4\pi}{3}$
 \item \macr{CSM\_TWOPIPIINV} : $\frac{1}{2\pi^2}$
 \item \macr{CSM\_TWOPIPIINVLOGTEN} : $\frac{\ln(10)}{2\pi^2}$
 \item \macr{CSM\_LOGTEN} : $\ln(10)$
 \item \macr{CSM\_RTOD} : $\frac{180}{\pi}$
 \item \macr{CSM\_DTOR} : $\frac{\pi}{180}$
 \item \macr{CSM\_HGYR} : $H_0^{-1}$ in units of Gyr$/h$
 \item \macr{CSM\_HMPC} : $c\,H_0^{-1}$ in units of Mpc$/h$
% \item \macr{CSM\_DELTAC} : spherical collapse threshold $\delta_c\equiv\frac{3}{5}\left(\frac{3\pi}{2}\right)^{2/3}$.
\end{itemize}

\section{Csm\_params}

In its current version ($>0.5$), CosmoMad defines the structure
{\tt Csm\_params}, which contains all the necessary information to
calculate all the supported quantities for a given cosmological 
model. It is not our intention to describe here the elements of
this structure, since the user is not supposed to meddle with it.
However, its definition and those of all related structures are
given in the header file {\tt cosmo\_mad.h}. Most of the functions
described below accept a {\tt Csm\_params} struct as their first
argument, which defines the cosmological model for which the 
calculation must be done (once the model has been initialized).
This prevents the use of global variables and allows the user to
compute the same quantity in different cosmological models
simultaneously.

A {\tt Csm\_params} structure contains all the information about
the background cosmological parameters, power-spectrum and 2-point
correlation function information.

%\section{Variables}

%The following quantities are available to the user once a cosmological model has been set:
%\begin{itemize}
% \item {\tt double} {\tt csm\_bang\_time}: the age of the Universe in Gyr$/h$.
% \item {\tt double} {\tt csm\_phorizon}: the particle horizon at $a=1$ in Mpc$/h$.
% \item {\tt double} {\tt csm\_a\_equality}: the value of $a$ at $M$-$\Lambda$ equality (or $M$-$k$ equality if it occurs before).
% \item {\tt double} {\tt csm\_growth0}: the amplitude of perturbations at $a=1$ assuming $D(a<<1)\simeq a$.
% \item {\tt double} {\tt csm\_EH\_rsound}: the scale of the sound horizon at decoupling in Mpc$/h$. This is computed using
%                                           Eisenstein \& Hu's parametrization (\cite{eandhu}).
% \item {\tt double} {\tt csm\_EH\_keq}: Fourier scale of the horizon at matter-radiation equality (E\&H parametrization).
% \item {\tt double} {\tt csm\_EH\_ksilk}: Fourier Silk damping scale (E\&H parametrization).
% \item {\tt double} {\tt csm\_EH\_zeq}: redshift to matter-radiation equality (E\&H parametrization).
% \item {\tt double} {\tt csm\_EH\_zdrag}: redshift to drag epoch (E\&H parametrization).
%\end{itemize}
%Note that these variables are used by CosmoMad and, therefore, should NEVER be written by the user.

\section{Routines}

All the functions provided by CosmoMad start with the prefix {\tt csm\_}.

\subsection{General behavior}

\begin{funcdef}[csm\_unset\_gsl\_eh]
 {\functi{void}{csm\_unset\_gsl\_eh}
 {\vari{void}{}}}
 A call to this function disables the default GSL error handler. This error handler is very
 strict and will exit the program if any problem (regarding, for example, the accuracy of
 an integral) is met. Since sometimes these problems are not so important (an integral reaching
 a $10^{-3}\%$ accuracy instead of $10^{-4}\%$ may not be problematic), you may want the program
 to continue its execution anyway. When called, a taylored error-handler will be used for the
 current run. This error handler will output error messages to {\tt stderr} beginning with
 ``CosmoMad: '', giving a hint as to what the encountered problem was, and it will exit the
 program if the error found is clearly important (like finding a NaN). It is recomended to call
 this function at the beginning of any program using CosmoMad.
\end{funcdef}


\begin{funcdef}[csm\_set\_verbosity]
{\functi{void}{csm\_set\_verbosity}
{\vari{int}{ verb}}}
 Determines the amount of information output. In the current version there are only two levels,
 0 (nothing) and 1 (everything). The default level of verbosity is 1 (all messages are output).
\end{funcdef}

\begin{funcdef}[csm\_params\_new]
{\functi{Csm\_params}{*csm\_params\_new}{\vari{void}{}}}
 Returns an initialized {Csm\_params} structure. Notice that this returns an empty structure,
 with no associated cosmological information.
\end{funcdef}

\begin{funcdef}[csm\_params\_free]
{\functi{void}{csm\_params\_free}{\vari{Csm\_params}{ *pars}}}
 Frees up all the memory associated with a {\tt Csm\_params} structure.
\end{funcdef}


\subsection{Mathematical functions}
These functions return the result given by the analogous {\tt GSL} routines and are only
provided for convenience.

\begin{funcdef}[csm\_p\_leg]
{\functi{double}{csm\_p\_leg}{\vari{int}{ l},\vari{double}{ x}}}
 Returns the {\tt l}-th Legendre polynomial evaluated at {\tt x}: $L_l(x)$.
\end{funcdef}

\begin{funcdef}[csm\_j\_bessel]
{\functi{double}{csm\_j\_bessel}{\vari{int}{ l},\vari{double}{ x}}}
 Returns the {\tt l}-th spherical Bessel function evaluated at {\tt x}: $j_l(x)$.
\end{funcdef}

\subsection{Background evolution}

\begin{funcdef}[csm\_background\_set]
{\functi{void}{csm\_background\_set}
{\vari{Csm\_params}{ *pars},\vari{double}{ OM},\vari{double}
{ OL},\vari{double}{ OB},\vari{double}{ w0},\vari{double}{ wa},\vari{double}{ hh},\vari{double}{ T\_CMB}}}
 Sets the background cosmology for the structure {\tt pars}:
 $\Omega_M={\tt OM}$, $\Omega_{DE}={\tt OL}$, $\Omega_b={\tt OB}$, $h={\tt hh}$,
 $w_0={\tt w0}$, $w_a={\tt wa}$, $T_{\rm CMB}={\tt TCMB}$,
 with the CMB temperature given in Kelvin. This function must be called for any
 {\tt Csm\_params} used.
\end{funcdef}

\newpage
\begin{funcdef}[csm\_cosmic\_time]
{\functi{double}{csm\_cosmic\_time}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the cosmic time corresponding to the scale factor {\tt aa} by calculating the integral
 \begin{equation}\label{eq:costime}
  t(a)=\int_0^{a}\frac{da'}{a'\,H(a')}=
  H_0^{-1}\int_0^{a}\left(\frac{x}{\Omega_M+\Omega_k\,x+\Omega_{DE}\,x^{-3w}}\right)^{1/2}dx
 \end{equation}
\end{funcdef}

\begin{funcdef}[csm\_scale\_factor]
{\functi{double}{csm\_scale\_factor}{\vari{Csm\_params}{ *pars},\vari{double}{ t}}}
 For cosmic time {\tt t} in Gyr$/h$, this function returns the value of the scale factor. The first time this
 function is called, the integral (\ref{eq:costime}) is used for several values of $a$ from 0 to 1 and a spline
 object is created to calculate $a(t)$ faster in all subsequent calls.
\end{funcdef}

\begin{funcdef}[csm\_hubble]
{\functi{double}{csm\_hubble}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the inverse Hubble horizon $H(a)$ at $a={\tt aa}$ in inverse length units.
\end{funcdef}

\begin{funcdef}[csm\_omega\_matter]
{\functi{double}{csm\_omega\_matter}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the matter parameter $\Omega_M(a)$ at $a={\tt aa}$.
\end{funcdef}

\begin{funcdef}[csm\_particle\_horizon]
{\functi{double}{csm\_particle\_horizon}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the comoving particle horizon (the maximum distance a particle can have travelled since
 $a=0$) at $a={\tt aa}$ by calculating the integral
 \begin{equation}\nonumber
  \chi_p(a)=c\int_0^{a}\frac{da'}{a'^2\,H(a')}=
  \frac{c}{H_0}\int_0^{a}\frac{dx}{x\sqrt{\Omega_M+\Omega_k\,x+\Omega_{DE}\,x^{-3w}}}
 \end{equation}
\end{funcdef}

\begin{funcdef}[csm\_radial\_comoving\_distance]
{\functi{double}{csm\_radial\_comoving\_distance}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the radial comoving distance $\chi(a)=\chi_p(1)-\chi_p(a)$ for $a={\tt aa}$.
\end{funcdef}

\begin{funcdef}[csm\_curvature\_comoving\_distance]
{\functi{double}{csm\_curvature\_comoving\_distance}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the curvature comoving distance at $a={\tt aa}$
 \begin{equation}\nonumber
  r(a)=\frac{c}{H_0\,\sqrt{|\Omega_k|}}\,{\rm sinn}(H_0\,\sqrt{|\Omega_k|}\,\chi(a)/c)
 \end{equation}
\end{funcdef}

\begin{funcdef}[csm\_angular\_diameter\_distance]
{\functi{double}{csm\_angular\_diameter\_distance}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the angular diameter distance at $a={\tt aa}$ 
 \begin{equation}\nonumber
  d_A(a)=a\,\,r(a)
 \end{equation}
\end{funcdef}

\begin{funcdef}[csm\_luminosity\_distance]
{\functi{double}{csm\_luminosity\_distance}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the luminosity distance at $a={\tt aa}$ 
 \begin{equation}\nonumber
  d_L(a)=\frac{r(a)}{a}
 \end{equation}
\end{funcdef}

\begin{funcdef}[csm\_growth\_factor\_and\_growth\_rate]
{\functi{void}{csm\_growth\_factor\_and\_growth\_rate}{\vari{Csm\_params}{ *pars},\vari{double}{ aa},\vari{double}{ *gf},\vari{double}{ *fg}}}
 Returns the growth factor $D(a)$ and the growth rate $f(a)$ at $a={\tt aa}$ in the variables {\tt gf} and {\tt fg} respectively.
 If both quantities are required at the same time it is more efficient to call this function than the two functions below, since
 both quantities are obtained at the same time when solving the differential equation for the growth of matter perturbations:
 \begin{equation}
   \frac{d}{da}\left(a^3\,H(a)\frac{dD}{da}\right)=\frac{3}{2}\Omega_M(a)\,H(a)\,a\,D
 \end{equation}
 Note that $D(a)$ is normalized to $D(a\rightarrow0)\rightarrow a$, and not $D(1)=1$.
\end{funcdef}

\begin{funcdef}[csm\_growth\_factor]
{\functi{double}{csm\_growth\_factor}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the growth factor at $a={\tt aa}$.
\end{funcdef}

\begin{funcdef}[csm\_f\_growth]
{\functi{double}{csm\_f\_growth}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the growth rate $f(a)$ at $a={\tt aa}$.
\end{funcdef}

\begin{funcdef}[csm\_theta\_BAO]
{\functi{double}{csm\_theta\_BAO}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the angular position (in degrees) of the BAO peak in the angular correlation function
 at $a={\tt aa}$:
 \begin{equation}\nonumber
  \theta_{BAO}(a)=\frac{a\,r_s}{d_A(a)}
 \end{equation}
\end{funcdef}

\begin{funcdef}[csm\_Dz\_BAO]
{\functi{double}{csm\_Dz\_BAO}{\vari{Csm\_params}{ *pars},\vari{double}{ aa}}}
 Returns the position (in $\Delta z$) of the BAO peak in the radial correlation function
 at $a={\tt aa}$:
 \begin{equation}\nonumber
  \Delta z_{BAO}(a)=\frac{H(a)\,r_s}{c}
 \end{equation}
\end{funcdef}

\newpage
\subsection{Power spectrum}

\begin{funcdef}[csm\_set\_linear\_pk]
{\functi{void}{csm\_set\_linear\_pk}
{\vari{Csm\_params}{ *pars},\vari{char}{ *fname},\vari{double}{ lkmn},\vari{double}{ lkmx},\\\vari{double}{ dlk},\vari{double}{ nns},\vari{double}{ s8}}}
 This function sets the linear matter power spectrum at $a=1$. There exist several options:
 \begin{itemize}
  \item If {\tt fname} is ``BBKS'' the power spectrum will be calculated from the BBKS transfer function (\cite{bbks}) in
  the interval ${\tt lkmn}<\log_{10}(k)<{\tt lkmx}$, in intervals of $\Delta\log_{10}(k)={\tt dlk}$.
  \item If {\tt fname} is ``EH'' the power spectrum will be calculated from the Eisenstein \& Hu transfer function
  \cite{eandhu} in the same fashion.
  \item If {\tt fname} is ``EH\_smooth'' the power spectrum will be calculated from the Eisenstein \& Hu transfer function
  {\bf without acoustic oscillations}.
  \item Finally {\tt fname} can be set to the path to a file containing the power spectrum. This file must be in CAMB format,
  i.e.: two columns ($k$, $P(k)$) with $k$ in $h/$Mpc and its values evenly spaced in $\log_{10}(k)$.
 \end{itemize}
 Once the $P(k)$ is read (or calculated) it is normalized to $\sigma_8={\tt s8}$. After that a spline object
 is created for faster interpolation thereafter. The normalization for $P(k)$ used here is such that
 \begin{equation}\nonumber
  \langle\delta({\bf x})\delta({\bf x}+{\bf r})\rangle\equiv\xi(r)=\frac{1}{2\pi^2}
  \int_0^{\infty}P(k)\,\frac{\sin(kr)}{kr}k^2dk
 \end{equation}
\end{funcdef}

\begin{funcdef}[csm\_set\_nonlinear\_pk]
{\functi{void}{csm\_set\_nonlinear\_pk}
{\vari{Csm\_params}{ *pars},\vari{char}{ *fnamePkHFIT}}}
 This function sets the non-linear matter power spectrum at $a=1$. Three options are available: if {\tt fnamePkHFIT} is
 set to ``RPT'' the mildly non-linear power spectrum is approximated by including a Gaussian damping term arising
 in renormalized perturbation theory (\cite{rpt}):
 \begin{equation}\nonumber
  P(k,z)=P^L(k,z)\,e^{-k^2\sigma_v^2(z)},
 \end{equation}
 where
 \begin{equation}\nonumber
  \sigma_v^2(z)=\frac{1}{6\pi^2}\int_0^{\infty}P^L(k,z)dk.
 \end{equation}
 Thus in this case $\sigma_v^2(z=0)$ is calculated and used in this way when calling {\tt csm\_Pk\_nonlinear\_0} (below).
 
 If {\tt fnamePkHFIT} is set to ``RPT\_ss'' this Gaussian damping factor is also used, however the small scales are
 recovered by adding a no-BAO power spectrum:
 \begin{equation}\nonumber
  P(k,z)=[P^L(k,z)-P^L_{\rm no BAO}(k,z)]\,e^{-k^2\sigma_v^2(z)}+P^L_{\rm no BAO}(k,z).
 \end{equation}
 The no-BAO $P(k)$ is obtained using the Eisenstein \& Hu \cite{eandhu} fitting formula without acoustic oscillations.
 This way only the BAO wiggles are damped.
 
 The last option is to set {\tt fnamePkHFIT} to the path to a file containing a non-linear power spectrum (for example
 using HALOFIT \cite{hfit}). The format for this file must be the same as the one used in {\tt csm\_set\_linear\_pk}.
 Note that in this case there is no way to normalize $P(k)$ to the value of $\sigma_8$ used for the linear power-spectrum,
 but CosmoMad will use the same normalization factor used for the linear case, so one should make sure that both the
 linear and non-linear $P(k)$'s were generated with the same normalization.
\end{funcdef}

\newpage
\begin{funcdef}[csm\_Pk\_linear\_0]
 {\functi{double}{csm\_Pk\_linear\_0}{\vari{Csm\_params}{ *pars},\vari{double}{ kk}}}
 Returns the linear matter power spectrum at $a=1$ and $k={\tt kk}$. If {\tt kk} is larger than the interpolation
 limits for $P(k)$ it is approximated by $P(k)\propto\,k^{n_s}$ for small $k$ and $P(k)\propto\,k^3$ for
 large $k$.
\end{funcdef}

\begin{funcdef}[csm\_Pk\_nonlinear]
 {\functi{double}{csm\_Pk\_nonlinear}{\vari{Csm\_params}{ *pars},\vari{double}{ kk}}}
 Returns the non-linear power spectrum at $k={\tt kk}$. If {\tt kk} is larger than the interpolation
 limits for $P(k)$ it is approximated by $P(k)\propto\,k^{n_s}$ for small $k$ and $P(k)\propto\,k^3$ for
 large $k$. This function returns the power spectrum normalized with the growth factor given in
 {\tt csm\_set\_Pk\_params}, but without bias or RSDs.
\end{funcdef}

\begin{funcdef}[csm\_set\_Pk\_params]
 {\functi{void}{csm\_set\_Pk\_params}{\vari{Csm\_params}{ *pars},\vari{double}{ beta},\vari{double}{ gf},
 \vari{double}{ bias},\vari{int}{ l\_max}}}
 Sets the parameters necessary to calculate the full power spectrum in redshift space: $\beta(a)={\tt beta}$,
 $D(a)={\tt gf}$  and $b={\tt bias}$ (see equation (\ref{eq:pk_full})). {\tt l\_max} is the maximum multipole
 that will be used in the calculation of the power spectru and 3D correlation funciton (e.g. 4 for the Kaiser
 approximation or 0 for the real-space case -- $\beta=0$).
\end{funcdef}

\begin{funcdef}[csm\_Pk\_full]
 {\functi{double}{csm\_Pk\_full}{\vari{Csm\_params}{ *pars},\vari{double}{ kk},\vari{double}{ muk}}}
 Returns the full redshift-space power spectrum in the Kaiser approximation (\cite{kai}):
 \begin{equation}\label{eq:pk_full}
  P_s(a,k,\mu_k)=b^2\,(1+\beta(a)\,\mu_k^2)^2\,P_r(a,k),
 \end{equation}
 with
 \begin{equation}\nonumber
  P_r(a,k)=[D(a)]^2\,P_{NL}(a,k),
 \end{equation}
 and
 \begin{equation}\nonumber
  P_{NL}(a,k)\equiv\,P_L(a=1,k)\exp\left(-[D(a)\,\sigma_v(0)]^2k^2\right)
 \end{equation}
 if RPT was used to set the non-linear power spectrum.
\end{funcdef}

\begin{funcdef}[csm\_Pk\_multipole]
 {\functi{double}{csm\_Pk\_multipole}{\vari{Csm\_params}{ *pars},\vari{double}{ kk},\vari{int}{ l}}}
 Returns the {\tt l}-th multipole of the power spectrum:
 \begin{equation}\nonumber
  P_l(k)=\frac{2l+1}{2}\int_{-1}^1L_l(\mu_k)\,P(k,\mu_k),
 \end{equation}
 where $L_l(x)$ is the $l$-th Legendre polynomial.
\end{funcdef}

\newpage
\subsection{Correlation functions}

\begin{funcdef}[csm\_xi2p\_L]
{\functi{double}{csm\_xi2p\_L}{\vari{Csm\_params}{ *pars},\vari{double}{ r},\vari{double}{ R1},\vari{double}{ R2},\\\vari{char}{ *wf1},\vari{char}{ *wf2},\vari{double}{ errfac}}}
 Let $\delta({\bf x};R,T)$ be the density contrast smoothed with a window function of type
 $T$ and smoothing scale $R$. This function returns the value of the correlation function between
 $\delta({\bf x};{\tt R1},{\tt wf1})$ and $\delta({\bf x}+{\tt r};{\tt R2},{\tt wf2})$. To be
 more specific, the return value is
 \begin{equation}\nonumber
  \xi(r;R_1,R_2)\equiv\frac{1}{2\pi^2}\int_0^{\infty}P_L(k,z=0)\,W_{T_1}(kR_1)\,W_{T_2}(kR_2)\,
                                                     j_0(kr)\,k^2dk
 \end{equation}
 The possible values for {\tt wf1} and {\tt wf2} are ``TopHat'' and ``Gauss'':
 \begin{equation}\nonumber
  W_{TH}(x)=3\,\frac{\sin\,x-x\,\cos\,x}{x^3},\,\,\,\,\,W_{G}(x)=\exp(-x^2/2).
 \end{equation}
 For some values of the parameters it may be impossible for the GSL integrator to obtain the
 required accuracy, in which case the error requirement can be altered through {\tt errfac}:
 the relative error will then be ${\tt errfac}\,10^{-4}$ (the recommended value for {\tt errfac}
 is thus 1).
\end{funcdef}

\begin{funcdef}[csm\_sig0\_L]
{\functi{double}{csm\_sig0\_L}{\vari{Csm\_params}{ *pars},\vari{double}{ R1},\vari{double}{ R2},\vari{char}{ *wf1},\vari{char}{ *wf2}}}
 With the notation above, this function returns the value of the covariance of between
 $\delta({\bf x};{\tt R1},{\tt wf1})$ and $\delta({\bf x};{\tt R2},{\tt wf2})$. I.e. this
 is equivalent to {\tt csm\_xi2p\_L(0,R1,R2,wf1,wf2,1)}.
\end{funcdef}

\begin{funcdef}[csm\_xi\_multipole]
{\functi{double}{csm\_xi\_multipole}{\vari{Csm\_params}{ *pars},\vari{double}{ rr},\vari{int}{ l}}}
 Returns the {\tt l}-th multipole of the redshift-space correlation function. This is done by performing the
 integral
 \begin{equation}\label{eq:xi_multi}
  \xi_l(r)=\frac{i^l}{2\pi^2}\int_0^{\infty}P_l(k)\,j_l(kr)\,k^2\,dk,
 \end{equation}
 where $P_l(k)$ is the $l$-th multipole of the redshift-space power spectrum (as returned by {\tt csm\_Pk\_multipole}).
 The first time this function is called a spline is created for each power spectrum multipole in order to accelerate
 the calculation of the integral above.
\end{funcdef}

\begin{funcdef}[csm\_set\_xi\_multipole\_splines]
{\functi{double}{csm\_set\_xi\_multipole\_splines}{\vari{Csm\_params}{ *pars}}}
 If the correlation function multipoles must be calculated repeatedly, it may be faster to calculate first the
 multipoles once for a set of $r$-values and then interpolate between these values. This function initializes a
 set of spline objects that are used thereafter when calling {\tt csm\_xi\_multipole}. Specifically, a logarithmic-spaced
 spline is used for $0.1\,{\rm Mpc}/h < r < 15\,{\rm Mpc}/h$, and a linear-spaced spline is used for $15\,{\rm Mpc}/h < r <
 500\,{\rm Mpc}/h$. Hence subsequent calls to this function will not calculate the integral (\ref{eq:xi_multi}),
 but a much faster interpolation. If this function is called, for $r>500\,{\rm Mpc}/h$, {\tt csm\_xi\_multipole} will return
 0, and for $r<0.1\,{\rm Mpc}/h$ it will return the value at $0.1\,{\rm Mpc}$.
\end{funcdef}

\begin{funcdef}[csm\_unset\_xi\_multipole\_splines]
{\functi{double}{csm\_unset\_xi\_multipole\_splines}{\vari{Csm\_params}{ *pars}}}
 Frees up all the memory associated to the splines created when calling {\tt csm\_set\_xi\_multipole\_splines}. It is not
 necessary to call this function at the end of each program, since {\tt csm\_params\_free} will also take care of this.
\end{funcdef}

\begin{funcdef}[csm\_xi\_3D]
{\functi{double}{csm\_xi\_3D}{\vari{Csm\_params}{ *pars},\vari{double}{ rr},\vari{double}{ mu}}}
 Returns the anisotropic 3-D correlation function $\xi(r,\mu)$ as a sum over multipoles:
 \begin{equation}\nonumber
  \xi(r,\mu)=\sum_{l=0}^{\infty}\xi_l(r)\,L_l(\mu).
 \end{equation}
 Note that under the Kaiser approximation (the one used in the present version of CosmoMad) only the first three
 multipoles ($l=0,\,2,\,4$) are used. When many calls to this function are necessary it may be wise to call 
 {\tt csm\_set\_multipole\_splines} first for a better performance.
\end{funcdef}

\begin{funcdef}[csm\_xi\_pi\_sigma]
{\functi{double}{csm\_xi\_pi\_sigma}{\vari{Csm\_params}{ *pars},\vari{double}{ pi},\vari{double}{ sigma},\vari{int}{ use\_multipoles}}}
 Returns the anisotropic 3-D correlation function $\xi(\pi,\sigma)$ using longitudinal ($\pi\equiv\,\mu$) and transverse
 ($\sigma\equiv\sqrt{r^2-\pi^2}$) coordinates. If {\tt use\_multipoles} is set to 1 the sum over multipoles described above
 is used. If set to 0 the following double integral is performed:
 \begin{equation}\nonumber
  \xi(\pi,\sigma)=\frac{1}{2\pi^2}\int_0^{\infty}dk_{\parallel}\cos(k_{\parallel}\,\pi)
  \int_0^{\infty}dk_{\perp}\,k_{\perp}\,J_0(k_{\perp}\,\sigma) P(k_{\parallel},k_{\perp}),
 \end{equation}
 where $J_0(x)$ is the 0-th order cylindrical Bessel function. Note that the latter approach, although exact, will be much
 slower than the former, unless a large number of multipoles is needed.
\end{funcdef}

\newpage
\subsection{Halo mass function}

\begin{funcdef}[csm\_M2R]
  {\functi{double}{csm\_M2R}{\vari{Csm\_params}{ *pars},\vari{double}{ mass}}}
  Returns the comoving radius of a sphere of mass {\tt mass} (in units of $M_{\odot}/h$).
  These two quantities are related through
  \begin{equation}
    M=\frac{4\pi}{3}\Omega_M\,(2.776\times10^{11}\,M_{\odot}/h)\,
    \left(\frac{R}{1\,{\rm Mpc}/h}\right)^3
  \end{equation}
\end{funcdef}

\begin{funcdef}[csm\_R2M]
  {\functi{double}{csm\_R2M}{\vari{Csm\_params}{ *pars},\vari{double}{ radius}}}
  Returns the mass of a sphere of comoving radius {\tt radius}.
\end{funcdef}

\begin{funcdef}[csm\_collapsed\_fraction]
  {\functi{double}{csm\_collapsed\_fraction}{\vari{Csm\_params}{ *pars},
      \vari{double}{ mass},\vari{char}{ *mf\_model}}}
  Returns the fraction of the Universe that has collapsed into halos
  of mass larger than {\tt mass} according to the mass function parametrization
  given by {\tt mv\_model}. Three models are supported:
  \begin{itemize}
    \item ``PS'', \cite{pschech}:
      \begin{equation}
        F_{\rm PS}(<M) = {\rm erfc}(\nu/\sqrt{2})
      \end{equation}
    \item ``JAP'', \cite{JAP}:
      \begin{equation}
        F_{\rm JAP}(<M) = \frac{\exp(-c\,\nu^2)}{1+a\,\nu^b},
      \end{equation}
      with $(a,b,c)=(1.529,0.704,0.412)$.
    \item ``ST'', \cite{shethtormen}:
      \begin{equation}
        F_{\rm ST}(<M) = A\left[{\rm erfc}\left(\sqrt{\frac{a}{2}}\nu\right)
          +\frac{\Gamma(1/2-p,a\,\nu^2/2)}
          {\sqrt{\pi}\,2^p}\right],
      \end{equation}
      with $(A,a,p)=(0.322,0.707,0.3)$.
  \end{itemize}
\end{funcdef}
%\subsection{Halo mass function}
%\begin{funcdef}[csm\_mass\_r]
%{\functi{double}{csm\_mass\_r}{\vari{double}{ R}}}
% Returns the total mass enclosed in a sphere of radius {\tt R}.
%\end{funcdef}

%\begin{funcdef}[csm\_radius\_m]
%{\functi{double}{csm\_mass\_r}{\vari{double}{ M}}}
% Returns the radius of a sphere enclosing a mass {\tt M} ($R({\tt M})$).
%\end{funcdef}

%\begin{funcdef}[csm\_sigmaM]
%{\functi{double}{csm\_sigmaM}{\vari{double}{ M}}}
% Returns $\sigma(M)$ defined as the variance of the overdensity field $\delta$ on spheres containing a mass $M$ at
% redshift $z=0$. Thus this function is equivalent to calling:
% \begin{equation}\nonumber
%  {\tt sqrt(csm\_sig0\_L(csm\_radius\_m(M),csm\_radius\_m(M),"TopHat","TopHat"))}.
% \end{equation}
%\end{funcdef}

%\begin{funcdef}[csm\_dlsigmaMdlM]
%{\functi{double}{csm\_dlsigmaMdlM}{\vari{double}{ M}}}
% Returns $-\frac{d\log\sigma(M)}{d\log M}$ calculated as:
% \begin{equation}
%  \frac{d\log\sigma(M)}{d\log M}=
%   \frac{\int_0^{\infty}k^2\,dk\,P_L(k)\,W_{TH}(kR)\,W'_{TH}(kR)\,kR}
%        {3\int_0^{\infty}k^2\,dk\,P_L(k)\,W^2_{TH}(kR)},
% \end{equation}
% where $R\equiv R(M)$ and 
%\end{funcdef}

%\begin{funcdef}[csm\_set\_nM\_splines]
%{\functi{void}{csm\_set\_nM\_splines}
%{\vari{double}{ lMmn},\vari{double}{ lMmx},\vari{double}{ dlM}}}
% This function initializes splines for a faster calculation of the two previous functions. These
% splines will cover masses in the range $\log M\in({\tt lMmn},{\tt lMmx})$ in intervals of $\Delta\log M = {\tt dlM}$.
% When calling these functions for a mass outside this range, the actual integrals will be calculated.
% If many calls to these functions or to the ones below will be needed, it is recommendable to call this
% function first.
%\end{funcdef}

%\begin{funcdef}[csm\_dndM]
%{\functi{double}{csm\_dndM}{\vari{double}{ MM},\vari{double}{ df},\vari{char}{ *model}}}
% Returns the mass function $n(M)$, defined so that $n(M)\,dM$ be the comoving number density of dark-matter
% halos of mass $M\in(M,M+dM)$, with $M={\tt MM}$. CosmoMad assumes a universal mass function (i.e.: depending
% on the cosmological parameters only through $\sigma(M)$), for which all redshift dependence is implicitly
% contained in $\sigma(z,M)=D(z)\,\sigma(0,M)$, in linear perturbation theory. The parameter ${\tt df}$ accounts
% for this redshift dependence, and is assumed to be the growth factor $D(z)$ at the desired redshift (i.e.: the
% mass function at $z=0$ will be recovered for ${\tt df}=1$). The mass function is calculated as
% \begin{equation}
%  n(M) = \frac{\rho_0}{M^2}\,g(\sigma)\,\left|\frac{d\log\sigma(M)}{d\log M}\right|,
% \end{equation}
% where the universal function $g(\sigma)$ depends on the mass function parametrization. CosmoMad admits several
% parametrizations:
% \begin{itemize}
%  \item {\bf Press \& Schechter} ({\tt model}$=${\tt "PS"}),   \cite{pschech}:
%  \begin{equation}
%   g_{PS}(\sigma) = \sqrt{\frac{2}{\pi}}\,\nu\,\exp\left(-\frac{\nu^2}{2}\right),
%  \end{equation}
%  where $\nu\equiv\delta_c/\sigma$ and $\delta_c\simeq1.686$ is the linearly extrapolated spherical collapse threshold
%  
%  \item {\bf Sheth \& Tormen} ({\tt model}$=${\tt "ST"}),   \cite{shethtormen}:
%  \begin{align}\nonumber
%   &g_{ST}(\sigma) = A\sqrt{\frac{2\,a}{\pi}}\left[1+\left(\frac{1}{a\,\nu^2}\right)^p\right]\,
%    \nu\,\exp\left(-a\frac{\nu^2}{2}\right),\\\nonumber
%   &(A,a,p) = (0.322,0.707,0.3).
%  \end{align}
%  
%  \item {\bf Jenkins} ({\tt model}$=${\tt "Jen"}),   \cite{jenkins}:
%  \begin{align}\nonumber
%   &g_{Jen}(\sigma) = B\exp\,[-|b-\log\sigma|^q],\\\nonumber
%   &(B,b,q) = (0.315,0.61,3.8).
%  \end{align}
%
%  \item {\bf Peacock} ({\tt model}$=${\tt "JAP"}), \cite{JAP}:
%  \begin{align}\nonumber
%   &g_{JAP}(\sigma) = \frac{a\,b\,\nu^b+2\,c\,nu^2(1+a\,\nu^b)}{(1+a\,\nu^b)^2}\exp(-c\nu^2),\\\nonumber
%   &(a,b,c) = (1.529,0.704,0.412).
%  \end{align}
%  \end{itemize}
%\end{funcdef}

%\begin{funcdef}[csm\_dfdM]
%{\functi{double}{csm\_dfdM}{\vari{double}{ MM},\vari{double}{ df},\vari{char}{ *model}}}
% Returns the multiplicity function $f(M)$, defined as the fraction of the mass collapsed into objects in a unit
% range of $\log M$:
% \begin{equation}
%  f(M) = \frac{M^2\,n(M)}{\rho_0}=g(\sigma)\,\left|\frac{d\log\sigma(M)}{d\log M}\right|.
% \end{equation}
%\end{funcdef}

\newpage
\section{Sample program}\label{sec:sample}

Here's a sample code using this library. This code takes a redshift as a command-line argument and calculates
several background quantities at that redshift, as well as the power spectrum and correlation functions (which
are written into ASCII files):

\lstinputlisting[language=C]{../src/nmt_main.c}

This code, together with its compilation script is included in the present version of CosmoMad
in the directory {\tt sample}.

\begin{thebibliography}{}
 \bibitem{bbks} Bardeen J.~M., Bond J.~R., Kaiser N., Szalay A.~S. (1986). {\sl The statistics of peaks of gaussian random fields}. ApJ, {\bf 304}:15
 \bibitem{rpt} Crocce M., Scoccimarro R. (2006) {\sl Renormalized cosmological perturbation theory}. PRD, {\bf 73}:063519
 \bibitem{eandhu} Eisenstein D.~J., Hu W. (1998). {\sl Baryonic features in the matter transfer function}. ApJ, {\bf 496}:605
% \bibitem{jenkins} Jenkins A. {\sl et al.} 2001, MNRAS, 321, 372
 \bibitem{kai} Kaiser N. (1987). {\sl  Clustering in real space and in redshift space}. MNRAS {\bf 227}:1
 \bibitem{JAP} Peacock J.~A. 2007, MNRAS, 379, 1067
 \bibitem{pschech} Press W.~H., Schechter P., 1974, ApJ, 187, 425
 \bibitem{shethtormen} Sheth R.~K. \& Tormen G. 2002, MNRAS, 329, 61
 \bibitem{hfit} Smith R. et al. (2003) {\sl Stable clustering, the halo model and nonlinear cosmological power spectra}. MNRAS, {\bf 341}:1311
\end{thebibliography}

\end{document}
